<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="2" skipped="0" tests="9" time="4.773" timestamp="2025-11-24T14:00:25.373341" hostname="LAPTOP-DQ96TM8K"><testcase classname="inventario_v3.testes.test_models" name="test_movimento_saida_decrementa_quantidade" time="0.326" /><testcase classname="inventario_v3.testes.test_models" name="test_movimento_saida_iguais_estoque_zera" time="0.004" /><testcase classname="inventario_v3.testes.test_models" name="test_model_str_returns_string" time="0.002" /><testcase classname="inventario_v3.testes.test_models" name="test_produto_change_quantidade_method" time="0.006"><failure message="assert 5 == 7&#10; +  where 5 = &lt;Produto: Pchg (5)&gt;.quantidade">@pytest.mark.django_db
    def test_produto_change_quantidade_method():
        p = Produto.objects.create(nome="Pchg", quantidade=5, preco="1.00")
        # Se existir método change_quantidade, testamos; caso contrário, apenas verificamos que a operação básica funciona
        if hasattr(p, "change_quantidade"):
            # supõe assinatura change_quantidade(delta)
            p.change_quantidade(2)
            p.refresh_from_db()
&gt;           assert p.quantidade == 7
E           assert 5 == 7
E            +  where 5 = &lt;Produto: Pchg (5)&gt;.quantidade

inventario_v3\testes\test_models.py:42: AssertionError</failure></testcase><testcase classname="inventario_v3.testes.test_models" name="test_movimento_quantidade_negativa_rejeitado" time="0.004"><failure message="django.db.utils.IntegrityError: CHECK constraint failed: quantidade">self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021AFAC16B10&gt;
sql = 'INSERT INTO "inventario_v3_movimento" ("produto_id", "tipo_movimento", "quantidade", "motivo", "criado_em", "usuario_id") VALUES (%s, %s, %s, %s, %s, %s) RETURNING "inventario_v3_movimento"."id"'
params = (1, 'ENTRADA', -3, '', '2025-11-24 17:00:26.066552', None)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='sqlite' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021AFAC16B10&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)

.venv\Lib\site-packages\django\db\backends\utils.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000021AFBC55010&gt;
query = 'INSERT INTO "inventario_v3_movimento" ("produto_id", "tipo_movimento", "quantidade", "motivo", "criado_em", "usuario_id") VALUES (?, ?, ?, ?, ?, ?) RETURNING "inventario_v3_movimento"."id"'
params = (1, 'ENTRADA', -3, '', '2025-11-24 17:00:26.066552', None)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
&gt;       return super().execute(query, params)
E       sqlite3.IntegrityError: CHECK constraint failed: quantidade

.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:328: IntegrityError

The above exception was the direct cause of the following exception:

    @pytest.mark.django_db
    def test_movimento_quantidade_negativa_rejeitado():
        p = Produto.objects.create(nome="Pneg", quantidade=5, preco="1.00")
        m = Movimento(produto=p, tipo_movimento=Movimento.MOV_ENT, quantidade=-3)
        # espera-se que salvar um movimento com quantidade negativa gere erro (ValueError ou ValidationError)
        with pytest.raises((ValueError, ValidationError)):
&gt;           m.save()

inventario_v3\testes\test_models.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
inventario_v3\models.py:79: in save
    return super().save(*args, **kwargs)
.venv\Lib\site-packages\django\db\models\base.py:814: in save
    self.save_base(
.venv\Lib\site-packages\django\db\models\base.py:877: in save_base
    updated = self._save_table(
.venv\Lib\site-packages\django\db\models\base.py:1020: in _save_table
    results = self._do_insert(
.venv\Lib\site-packages\django\db\models\base.py:1061: in _do_insert
    return manager._insert(
.venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
.venv\Lib\site-packages\django\db\models\query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
.venv\Lib\site-packages\django\db\models\sql\compiler.py:1820: in execute_sql
    cursor.execute(sql, params)
.venv\Lib\site-packages\django\db\backends\utils.py:67: in execute
    return self._execute_with_wrappers(
.venv\Lib\site-packages\django\db\backends\utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
.venv\Lib\site-packages\django\db\backends\utils.py:84: in _execute
    with self.db.wrap_database_errors:
.venv\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
.venv\Lib\site-packages\django\db\backends\utils.py:89: in _execute
    return self.cursor.execute(sql, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000021AFBC55010&gt;
query = 'INSERT INTO "inventario_v3_movimento" ("produto_id", "tipo_movimento", "quantidade", "motivo", "criado_em", "usuario_id") VALUES (?, ?, ?, ?, ?, ?) RETURNING "inventario_v3_movimento"."id"'
params = (1, 'ENTRADA', -3, '', '2025-11-24 17:00:26.066552', None)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
&gt;       return super().execute(query, params)
E       django.db.utils.IntegrityError: CHECK constraint failed: quantidade

.venv\Lib\site-packages\django\db\backends\sqlite3\base.py:328: IntegrityError</failure></testcase><testcase classname="inventario_v3.testes.test_views" name="test_criar_produto_via_view_invalido" time="1.337" /><testcase classname="inventario_v3.testes.test_views" name="test_criar_movimento_view_requer_login" time="0.004" /><testcase classname="inventario_v3.testes.test_views" name="test_produto_detail_view_exists_and_shows_product" time="1.208" /><testcase classname="inventario_v3.testes.test_views" name="test_create_movimento_persists_and_updates_stock" time="1.256" /></testsuite></testsuites>